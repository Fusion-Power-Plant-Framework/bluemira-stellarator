# ---
# jupyter:
#   jupytext:
#     cell_metadata_filter: tags,-all
#     notebook_metadata_filter: -jupytext.text_representation.jupytext_version
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% tags=["remove-cell"]
# SPDX-FileCopyrightText: 2021-present M. Coleman, J. Cook, F. Franza
# SPDX-FileCopyrightText: 2021-present I.A. Maione, S. McIntosh
# SPDX-FileCopyrightText: 2021-present J. Morris, D. Short
#
# SPDX-License-Identifier: LGPL-2.1-or-later

"""
A geometry tutorial for users.
"""

# %% [markdown]
# # Geometry Tutorial
# ## Introduction
#
# Geometry is not plasma physics, but it isn't trivial either. Chances are most of
# your day-to-day interaction with bluemira will revolve around geometry in some form
# or another. Puns intended.
#
# There a few basic concepts you need to familiarise yourself with:
# * Basic objects: [`BluemiraWire`, `BluemiraFace`, `BluemiraShell`, `BluemiraSolid`]
# * Basic properties
# * Matryoshka structure
# * Geometry creation
# * Geometry modification
# * Geometry operations
#
# ## Imports
#
# Let's start out by importing all the basic objects, and some typical tools

# %%
import json
from pathlib import Path
from typing import Any

import matplotlib.pyplot as plt
import numpy as np

from bluemira.base.file import get_bluemira_path

# Some display functionality
from bluemira.display import plotter, show_cad
from bluemira.display.displayer import DisplayCADOptions

# Basic objects
from bluemira.geometry.coordinates import Coordinates
from bluemira.geometry.face import BluemiraFace
from bluemira.geometry.shell import BluemiraShell
from bluemira.geometry.solid import BluemiraSolid

# Some useful tools
from bluemira.geometry.tools import (
    boolean_cut,
    boolean_fuse,
    extrude_shape,
    interpolate_bspline,
    make_bspline,
    make_bsplinesurface,
    make_circle,
    make_polygon,
    revolve_shape,
    save_cad,
    sweep_shape,
)
from bluemira.geometry.wire import BluemiraWire

# %% [markdown]
# Creating a 3D representation of a stellarator plasma surface generated by Simsopt


def read_json(file_path: str) -> dict[str, Any]:
    """Read JSON data from a file."""
    with open(file_path) as f:
        return json.load(f)


def align_to_surface(surface, path, offset=0.2):
    """
    Aligns the rectangle to be parallel to the surface of the plasma.
    """
    x, y, z = path.discretise()[0][1], path.discretise()[1][1], path.discretise()[2][1]

    # Find the normal of the surface at the closest point
    # Assuming `surface` has a method to get the normal vector at a point
    # This might need adjusting depending on the actual method used
    normal_vector = surface.get_normal_vector_at_point([x, y, z])
    normal_vector /= np.linalg.norm(normal_vector)  # Normalize the normal vector

    # Define rectangle points around the path point, aligned with the surface normal
    tangent_vector = np.gradient([x, y, z], axis=1)
    tangent_vector /= np.linalg.norm(tangent_vector, axis=0)  # Normalize tangent vector

    binormal_vector = np.cross(tangent_vector, normal_vector)
    binormal_vector /= np.linalg.norm(
        binormal_vector, axis=0
    )  # Normalize binormal vector

    # Create the points for the rectangle
    points = np.array([
        [
            x + offset * (-binormal_vector[0] - normal_vector[0]),
            x + offset * (binormal_vector[0] - normal_vector[0]),
            x + offset * (binormal_vector[0] + normal_vector[0]),
            x + offset * (-binormal_vector[0] + normal_vector[0]),
        ],
        [
            y + offset * (-binormal_vector[1] - normal_vector[1]),
            y + offset * (binormal_vector[1] - normal_vector[1]),
            y + offset * (binormal_vector[1] + normal_vector[1]),
            y + offset * (-binormal_vector[1] + normal_vector[1]),
        ],
        [
            z + offset * (-binormal_vector[2] - normal_vector[2]),
            z + offset * (binormal_vector[2] - normal_vector[2]),
            z + offset * (binormal_vector[2] + normal_vector[2]),
            z + offset * (-binormal_vector[2] + normal_vector[2]),
        ],
    ])

    return points


generic_surface_filename = (
    get_bluemira_path("", subfolder="examples/data/codes/simsopt")
    + "/plasma_surface_nurbs_data.json"
)

generic_magnet_filename = (
    get_bluemira_path("", subfolder="examples/data/codes/simsopt")
    + "/magnets_nurbs_data.json"
)

# Read in the json data
generic_surface_data = read_json(generic_surface_filename)
generic_magnet_data = read_json(generic_magnet_filename)


# Create a plasma surface from NURBS surface data
generic_plasma_surface = make_bsplinesurface(
    poles=generic_surface_data["poles2d"],
    mults_u=generic_surface_data["mults_u"],
    mults_v=generic_surface_data["mults_v"],
    knot_vector_u=generic_surface_data["internal_knot_vector_u"],
    knot_vector_v=generic_surface_data["internal_knot_vector_v"],
    degree_u=generic_surface_data["degree_u"],
    degree_v=generic_surface_data["degree_v"],
    weights=generic_surface_data["weights_reshaped"],
    periodic=False,
    check_rational=False,
)

# Now we create the magnets from NURBS curve data.
generic_magnet_curves = []
generic_magnet_solid = []
rectangles = []
for curve_dict in generic_magnet_data:
    magnet_curve = make_bspline(
        poles=curve_dict["poles"],
        mults=curve_dict["mults"],
        knots=curve_dict["internal_knot_vector"],
        degree=curve_dict["degree"],
        weights=curve_dict["weights"],
        periodic=False,
        check_rational=False,
    )
    generic_magnet_curves.append(magnet_curve)
    path = BluemiraWire([magnet_curve])
    x, y, z = path.discretise()[0][1], path.discretise()[1][1], path.discretise()[2][1]
    points = align_to_surface(generic_plasma_surface, path)

    rectangle = BluemiraFace(make_polygon(points, closed=True))
    rectangles.append(rectangle)
    solid = sweep_shape(rectangle.boundary[0], path, solid=False, frenet=True)
    generic_magnet_solid.append(solid)


# print((path.discretise()[0][1], path.discretise()[1][1]), path.discretise()[2][1])


# Show the CAD of the plasma surface and magnets.
show_cad(generic_magnet_curves + [generic_plasma_surface] + rectangles)
show_cad(generic_magnet_curves + [generic_plasma_surface] + generic_magnet_solid)
# %% Plot a stellarator plasma surface and required magnets


def read_json(file_path: str) -> dict[str, Any]:
    """Read JSON data from a file."""
    with open(file_path) as f:
        return json.load(f)


helias_surface_filename = (
    get_bluemira_path("", subfolder="examples/data/codes/simsopt")
    + "/helias_surface_nurbs_data.json"
)

helias_magnet_filename = (
    get_bluemira_path("", subfolder="examples/data/codes/simsopt")
    + "/helias_magnets_nurbs_data.json"
)

# Read in the json data
helias_surface_data = read_json(helias_surface_filename)
helias_magnet_data = read_json(helias_magnet_filename)

# Create a plasma surface from NURBS surface data
helias_plasma_surface = make_bsplinesurface(
    poles=helias_surface_data["poles2d"],
    mults_u=helias_surface_data["mults_u"],
    mults_v=helias_surface_data["mults_v"],
    knot_vector_u=helias_surface_data["internal_knot_vector_u"],
    knot_vector_v=helias_surface_data["internal_knot_vector_v"],
    degree_u=helias_surface_data["degree_u"],
    degree_v=helias_surface_data["degree_v"],
    weights=helias_surface_data["weights_reshaped"],
    periodic=False,
    check_rational=False,
    label="splinsurface",
)

# Now we create the magnets from NURBS curve data.
helias_magnet_curves = []
for curve_dict in helias_magnet_data:
    magnet_curve = make_bspline(
        poles=curve_dict["poles"],
        mults=curve_dict["mults"],
        knots=curve_dict["internal_knot_vector"],
        degree=curve_dict["degree"],
        weights=curve_dict["weights"],
        periodic=False,
        check_rational=False,
    )
    helias_magnet_curves.append(magnet_curve)

# Show the CAD of the plasma surface and magnets.
show_cad(helias_magnet_curves + [helias_plasma_surface])
